# Understanding Computation

> And this is what operational semantics really is: explaining the meaning of a language by describing an interpreter.
---
> **Comparing Semantic Styles**
> «while» is a good example of the difference between small-step, big-step, and denotational semantics.
> The small-step operational semantics of «while» is written as a reduction rule for an abstract machine. The overall looping behavior isn’t part of the rule’s action—reduction just turns a «while» statement into an «if» statement—but it emerges as a consequence of the future reductions performed by the machine. To understand what «while» does, we need to look at all of the small-step rules and work out how they interact over the course of a SIMPLE program’s execution.
> «while»’s big-step operational semantics is written as an evaluation rule that shows how to compute the final environment directly. The rule contains a recursive call to itself, so there’s an explicit indication that «while» will cause a loop during evaluation, but it’s not quite the kind of loop that a SIMPLE programmer would recognize. Big-step rules are written in a recursive style, describing the complete evaluation of an expression or statement in terms of the evaluation of other pieces of syntax, so this rule tells us that the result of evaluating a «while» statement may depend upon the result of evaluating the same statement in a different environment, but it requires a leap of intuition to connect this idea with the iterative behavior that «while» is supposed to exhibit. Fortunately the leap isn’t too large: a bit of mathematical reasoning can show that the two kinds of loop are equivalent in principle, and when the metalanguage supports tail call optimization, they’re also equivalent in practice.
> The denotational semantics of «while» shows how to rewrite it in Ruby, namely by using Ruby’s while keyword. This is a much more direct translation: Ruby has native support for iterative loops, and the denotation rule shows that «while» can be implemented with that feature. There’s no leap required to understand how the two kinds of loop relate to each other, so if we understand how Ruby while loops work, we understand SIMPLE «while» loops too. Of course, this means we’ve just converted the problem of understanding SIMPLE into the problem of understanding the denotation language, which is a serious disadvantage when that language is as large and ill-specified as Ruby, but it becomes an advantage when we have a small mathematical languagefor writing denotations.
---
> We saw earlier that operational semantics is about explaining a language’s meaning by designing an interpreter for it. By contrast, the language-to-language translation of denotational semantics is like a compiler: in this case, our implementations of #to_ruby effectively compile SIMPLE into Ruby. None of these styles of semantics necessarily says anything about how to efficiently implement an interpreter or compiler for a language, but they do provide an official baseline against which the correctness of any efficient implementation can be judged.
